#!/usr/bin/env bash

## General options ## 

host_cache_path="$HOME/.ser"
host_cache_file="$host_cache_path/cache"
host_cache_date="$host_cache_path/cache_date"
host_forward_options="$host_cache_path/forward_options"
host_forward_sessions_dirname='forward_sessions'
host_forward_sessions="$host_cache_path/$host_forward_sessions_dirname"
host_forward_crontab_task="$HOME/.ser/forward_crontab_task"

version='0.0.3a'

config_files=("/etc/ssh/ssh_config")

COLOR_LIGHT_GRAY='\033[0;37m'
COLOR_GREEN='\033[0;32m'
COLOR_RED='\033[0;31m'
NC='\033[0m'

REGEXP_NUMBER='^[0-9]+$'
REGEXP_LETTER='^[A-Za-z]+$'

error () { echo "$1" >&2; exit 2; }
trim () { while read -r line; do echo "$line"; done; }

## Config reader ## 

read_config() {

    check_host_name() {
        if [[ "$1" == "*" ]]; then return 0; fi
        if [[ "$1" == *"*"* || "$1" == *"?"* || "$1" == *"!"* || "$1" == *","* ]]; then return 1; fi
        return 0
    }

    local IFS='
'
    set -f

    local host; local content

    for l in $(cat "${@}" | trim) 
    do
        local IFS='#'; read -r -a l <<< "$l"; local IFS=" "; local options=()

        for p in ${l[0]}; do options+=($p); done

        case ${options[0]} in
            Host)
                if [[ -n "${host[*]}" ]]; then
                    [[ -n ${host[3]} ]] && host_port="${host[3]}" || host_port="#"
                    content+="${host[0]} ${host[1]} ${host[2]} ${host_port}\n"    
                fi

                check_host_name "${options[1]}" || error "sorry, patterns not support: ${options[1]}"

                if [[ ${options[1]} == "*" ]]; then
                    host=(); continue
                fi

                host=(${options[1]} $USER "" "") ;;
            User) 
                [[ -n "${host[*]}" ]] && host[1]=${options[1]} ;;
            HostName) 
                [[ -n "${host[*]}" ]] && host[2]=${options[1]} ;;
            Port) 
                [[ -n "${host[*]}" ]] && host[3]=${options[1]} ;;
            Match)
                error "sorry, 'Match' option not support" ;;
            *) ;;
        esac
    done
 
    # handle last one
    if [[ -n "${host[*]}" ]]; then
        [[ -n ${host[3]} ]] && host_port="${host[3]}" || host_port="#"
        content+="${host[0]} ${host[1]} ${host[2]} ${host_port}\n"    
    fi

    echo -e "$content"
}

need_flush() {
    local last; local cur

    [[ -a "$host_cache_date" ]] && last=$(cat "$host_cache_date") 

    case $(uname) in
        Linux) 
            cur=$(sha1sum <<< "$version $(stat --printf="%Y" "$@")") ;;
        Darwin) 
            cur=$(shasum <<< "$version $(stat -f "%m" "$@")") ;;
        *) 
            error "failed to read file modify time on $(uname)" ;;
    esac

    if [[ "$last" == "$cur" ]]; then
        return 1
    else
        echo "$cur" > "$host_cache_date"
        return 0
    fi
}

host_index=0
host=()
hosts=()

match_host () { 
    eval "[[ $1 == $2 ]]" 2>/dev/null # ignore syntax error
}

next_host () {
    [[ -z "${hosts[host_index]}" ]] && return 1
    local IFS=' '; host=(${hosts[host_index]})
    ((host_index++))
    return 0
}

token () {
    local s=${1//'{name}'/${host[0]}}
    s=${s//'{i}'/${host_index}}
    echo "$s"
}

select_hosts () {
    local name="$1"
    [[ -z "$name" ]] && name='*' 
    set -f

    local num_re='^[0-9]+$'

    if [[ "$name" =~ $num_re ]]; then 
        hosts+=("$(sed -n "${name}p" <<< "$content")")
        return
    fi

    local IFS='
'
    for l in $content 
    do
        local IFS=' '; local host=($l)
        match_host "${host[0]}" "${name}" && hosts+=("$l")
    done
}

help () {
    case $1 in
        name)
echo 'usage: ser name [name] 

print config names

examples:
    ser name
    ser name "*"
    ser name "my*"
' ;;
        cp) 
echo 'usage: ser cp <from> <to> [pass to scp options] 

copy file to hosts 

examples:
    ser cp "file" "*:~/"
    ser cp "*:~/file" "save/to/path/file-{name}"
    ser cp "dir" "*:~/" -r
    ser cp "*:~/dir" "save/to/path/{name}" -r

tokens:
    (see "ser help o" tokes section)';;
        o) 
echo 'usage: ser o <hostname|index> [command] [redirect result to file] 

login or executed command on the remote host

examples:
    ser "host1"
    ser o "host1"
    ser "host1"
    ser "*" "ls"
    ser "*" "ls" "result-{name}"

tokens:
    {i} - config index
    {name} - config name';;
        *) 
echo 'usage: ser <command> 

Type "ser help <command>" for help on a specific command.

Available commands:
    o|<hostname|index>        : open ssh client
    name                      : list all config names  
    cp                        : copy file to hosts

    forward-new|f             : create a new forward
    forward-delete|del        : delete forward
    forward-list|fl           : list all forward
    forward-generate|gen      : generate sessions configs

    session-start|start       : start sessions
    session-stop|stop         : stop sessions
    session-list|sl           : list all sessions
    session-check-step|step   : reconnect or add forward to sessions if enabled

    help                      : show this message
'
echo "ver:${version},github:https://github.com/frimin/ser" ;;

    esac
}

show_list () {
    local host=()
    local IFS='
'
    local i=0
    for l in $1 
    do
        local IFS=' '; read -r -a host <<< "$l"
        local host_port=""
        ! [[ "${host[3]}" == "#" ]] && host_port=":${host[3]}"
        ((i++)); echo -e "$i) ${COLOR_LIGHT_GRAY}${host[0]}${NC} - ${host[1]}@${host[2]}${host_port}"
    done
}

[[ ! -d "$host_cache_path" ]] && mkdir "$host_cache_path"
[[ -a "$HOME/.ssh/config" ]] && config_files+=("$HOME/.ssh/config")

if need_flush "${config_files[@]}"; then
    content=$(read_config "${config_files[@]}")
    echo "$content" > "$host_cache_file"
else
    content=$(cat "$host_cache_file")
fi

if [[ -z "$1" ]]; then 
    show_list "$content"; exit
fi

ssh_connect () {
    select_hosts "$1"

    while next_host; 
    do
        [[ -z "$2" ]] && echo "connecting \"${host[0]}\""

        if [[ -n "$3" ]]; then
            ssh "${host[0]}" $"$2" > "$(token "$3")" || exit
        else
            ssh "${host[0]}" $"$2" || exit
        fi
    done

    [[ $host_index -eq 0 ]] && error "no matching host(s): $1"

    exit 0
}

read_session_alived_status() {
    pgrep -fl ssh | grep -E '^[0-9]+ ssh .*'"$host_forward_sessions_dirname"
}

read_session_enabled_status() {
    cat "$host_forward_sessions/"*.enabled 2>/dev/null
}

select_session() {
    session_alive_status=$(read_session_alived_status)
    session_enabled_status=$(read_session_enabled_status)

    SESSION_INDEX=0
    SESSION=''
    SESSION_SETS=()

    for name in $host_forward_sessions/*.forward
    do
        name=$(basename "$name")
        name="${name%.*}"
        SESSION_SETS+=("$name")
    done
}

next_session () {
    [[ -z "${SESSION_SETS[SESSION_INDEX]}" ]] && return 1
    SESSION="${SESSION_SETS[SESSION_INDEX]}"
    ((SESSION_INDEX++))
    return 0
}

select_session_forward() {
    FORWARD_INDEX=0
    FORWARD=()
    FORWARD_SETS=()

    local IFS='
'
    FORWARD_SETS=($(cat "$host_forward_sessions/$SESSION.forward"))
}

next_forward () {
    [[ -z "${FORWARD_SETS[FORWARD_INDEX]}" ]] && return 1
    local IFS=' '; FORWARD=(${FORWARD_SETS[FORWARD_INDEX]})
    ((FORWARD_INDEX++))
    return 0
}

session_alived() {
    local count

    count="$(grep "ControlPath=$host_forward_sessions/$SESSION.sock" <<< "$session_alive_status" | wc -l | trim)"

    if [[ $count -eq 0 ]]; then
        return 1
    fi

    if [[ $count -eq 1 ]]; then
        #local IFS=' '
        #arr=($(grep "ControlPath=$host_forward_sockets/$1_$2.sock" <<< "$session_alive_status"))
        #SESSION_PID=${arr[0]}
        # remove it 
        session_alive_status=$(grep -v "ControlPath=$host_forward_sessions/$SESSION.sock" <<< "$session_alive_status")
        return 0
    fi
    
    error "invalid process alived count"
}

session_enabled() {
    if [[ -a "$host_forward_sessions/$SESSION.enabled" ]]; then
        return 0
    else
        return 1
    fi
}

session_connect() {
    local ssh_options=(
        '-o' 'ControlMaster=auto'
        '-o' "ControlPath=$host_forward_sessions/${SESSION}.sock"
        '-o' 'ExitOnForwardFailure=yes'
        '-o' 'ConnectTimeout=30'
        '-o' 'ServerAliveInterval=30'
        '-o' 'ServerAliveCountMax=3'
        '-o' 'BatchMode=yes'
    )

    select_session_forward

    local hostname

    while next_forward
    do
        if [[ "$FORWARD_INDEX" -eq 1 ]]; then
            hostname="${FORWARD[0]}"
        fi

        case "${FORWARD[1]}" in 
            local) ssh_options+=('-L' "${FORWARD[2]}:${FORWARD[3]}") ;;
            remote) ssh_options+=('-R' "${FORWARD[2]}:${FORWARD[3]}") ;;
            *) error "invalid forward type: '${FORWARD[*]}'" ;;
        esac
    done

    ssh -fN "$hostname" ${ssh_options[@]}
}

case $1 in
    help)
        help "$2" ;;
    name)
        select_hosts "$2"

        while next_host; 
        do
            echo "${host[0]}"
        done ;;
    cp)
        set -f; IFS=':'
        from=($2); to=($3)
        [[ ${#from[@]} -lt 2 && ${#to[@]} -lt 2 ]] && error "need to pass <host> or <index> for copy to or copy from" 

        if [[ ${#from[@]} -lt 2 ]]; then
            pattern="${to[0]}"
            from_path="$2"    
            from_head=""
            to_head="<host>:"
            to_path="${3#*:}"
        else
            pattern="${from[0]}"
            from_head="<host>:"
            from_path="${2#*:}"
            to_head=""
            to_path="$3"
        fi

        # echo "pattern \"$pattern\", ${from_head}${from_path} => ${to_head}${to_path}"

        select_hosts "$pattern"

        pass_options=(${@:4})

        while next_host; 
        do
            [[ -n "$from_head" ]] && from_head="${host[0]}:"
            [[ -n "$to_head" ]] && to_head="${host[0]}:"

            arg0="${from_head}$(token "${from_path}")"
            arg1="${to_head}$(token "${to_path}")"

            echo "copy \"${arg0}\" to \"${arg1}\""

            if ! [[ "${host[3]}" == "#" ]]; then
                scp -P "${host[3]}" ${pass_options[@]} "${arg0}" "${arg1}" || exit
            else
                scp ${pass_options[@]} "${arg0}" "${arg1}" || exit
            fi
        done ;;
    o)
        set -f; ssh_connect ${@:2} ;;  
    session-list|sl)
        select_session

        while next_session
        do
            select_session_forward

            if session_enabled; then
                state="[${COLOR_GREEN}enabled${NC}]"
            else
                state="[${COLOR_RED}disabled${NC}]"
            fi

            if session_alived; then
                state="$state [${COLOR_GREEN}connected${NC}]"
            else
                state="$state [${COLOR_RED}disconnect${NC}]"
            fi

            while next_forward
            do
                if [[ "$FORWARD_INDEX" -eq 1 ]]; then
                    echo -e "$SESSION_INDEX) ${COLOR_LIGHT_GRAY}${SESSION}${NC} - [${FORWARD[0]}] ${state}"
                fi

                case "${FORWARD[1]}" in 
                    local) echo " - ($SESSION_INDEX) LocalForward ${FORWARD[2]} <= ${FORWARD[3]}" ;;
                    remote) echo " - ($SESSION_INDEX) RemoteForward ${FORWARD[2]} => ${FORWARD[3]}" ;;
                    *) error "invalid line: '$LINE'" ;;
                esac
            done
        done
        ;;
    session-start|start)
        if [[ -z $2 ]]; then
            session_name='*'
        else
            session_name=$2
        fi

        select_session

        while next_session
        do
            if [[ "${SESSION}" == ''$session_name ]]; then
                echo "${SESSION}" > "${host_forward_sessions}/${SESSION}.enabled" 

                echo -e "[${COLOR_GREEN}START SESSION${NC}] - $SESSION: \c"

                if session_connect; then
                    echo 'OK'
                else
                    echo "FAILED, EXIT CODE: $?"
                fi
            fi
        done
        ;;
    session-stop|stop)
        if [[ -z $2 ]]; then
            session_name='*'
        else
            session_name=$2
        fi

        IFS='
'
        while read -r LINE
        do
            if [[ "$LINE" == *"$host_forward_sessions/"${session_name}\.sock* ]]; then
                IFS=' '
                arr=($LINE)
                pid="${arr[0]}"
                name="$(grep -o "$host_forward_sessions_dirname"'/.*\.sock' <<< "$LINE")"
                name=$(basename "$name")
                name="${name%.*}"

                /bin/rm -f "$host_forward_sessions/$name.enabled" # disable session

                echo -e "[${COLOR_RED}STOP SESSION${NC}] - $name (pid:$pid)"

                kill -s INT "$pid"
            fi
        done <<< "$(read_session_alived_status)"
        ;;
    check|session-check-step)
        select_session

        while next_session
        do
            select_session_forward

            if ! session_enabled; then
                continue
            fi

            if session_alived; then
                continue
            fi
           
            echo -e "[${COLOR_GREEN}START SESSION${NC}] - $SESSION: \c"

            if session_connect; then
                echo 'OK'
            else
                echo "FAILED, EXIT CODE: $?"
            fi

        done ;;
    *)
        set -f; ssh_connect $@ ;; 
esac

