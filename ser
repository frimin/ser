#!/usr/bin/env bash

## General options ## 

host_cache_path="$HOME/.ser"
host_cache_file="$host_cache_path/cache"
host_cache_date="$host_cache_path/cache_date"
host_forward_sessions_dirname='forward_sessions'
host_forward_sessions="$host_cache_path/$host_forward_sessions_dirname"
#host_forward_crontab_task="$HOME/.ser/forward_crontab_task"

version='0.0.3a'

SSH_CONFIG_FILES=("/etc/ssh/ssh_config" "$HOME/.ssh/config")

COLOR_LIGHT_GRAY='\033[0;37m'
COLOR_GREEN='\033[0;32m'
COLOR_RED='\033[0;31m'
NC='\033[0m'

REGEXP_NUMBER='^[0-9]+$'
REGEXP_SESSION_NAME='^[A-Za-z0-9_\-]+$'
REGEXP_SPACE='[ \n\t\r\f\v]+'

error () { echo "$1" >&2; exit 2; }
trim () { while read -r line; do echo "$line"; done; }

## Config reader ## 

read_host_config_from_ssh_config() {
    check_host_name() {
        if [[ "$1" == "*" ]]; then return 0; fi
        if [[ "$1" == *"*"* || "$1" == *"?"* || "$1" == *"!"* || "$1" == *","* ]]; then return 1; fi
        return 0
    }

    local IFS='
'
    set -f

    local host; local content

    for l in $(cat "${SSH_CONFIG_FILES[@]}" | trim) 
    do
        local IFS='#'; read -r -a l <<< "$l"; local IFS=" "; local options=()

        for p in ${l[0]}; do options+=($p); done

        case ${options[0]} in
            Host)
                if [[ -n "${host[*]}" ]]; then
                    [[ -n ${host[3]} ]] && host_port="${host[3]}" || host_port="#"
                    content+="${host[0]} ${host[1]} ${host[2]} ${host_port}\n"    
                fi

                check_host_name "${options[1]}" || error "sorry, patterns not support: ${options[1]}"

                if [[ ${options[1]} == "*" ]]; then
                    host=(); continue
                fi

                host=(${options[1]} $USER "" "") ;;
            User) 
                [[ -n "${host[*]}" ]] && host[1]=${options[1]} ;;
            HostName) 
                [[ -n "${host[*]}" ]] && host[2]=${options[1]} ;;
            Port) 
                [[ -n "${host[*]}" ]] && host[3]=${options[1]} ;;
            Match)
                error "sorry, 'Match' option not support" ;;
            *) ;;
        esac
    done
 
    # handle last one
    if [[ -n "${host[*]}" ]]; then
        [[ -n ${host[3]} ]] && host_port="${host[3]}" || host_port="#"
        content+="${host[0]} ${host[1]} ${host[2]} ${host_port}\n"    
    fi

    echo -e "$content"
}

need_flush() {
    local last; local cur

    [[ -a "$host_cache_date" ]] && last=$(cat "$host_cache_date") 

    case $(uname) in
        Linux) 
            cur=$(sha1sum <<< "$version $(stat --printf="%Y" "$@")") ;;
        Darwin) 
            cur=$(shasum <<< "$version $(stat -f "%m" "$@")") ;;
        *) 
            error "failed to read file modify time on $(uname)" ;;
    esac

    if [[ "$last" == "$cur" ]]; then
        return 1
    else
        echo "$cur" > "$host_cache_date"
        return 0
    fi
}

host_index=0
host=()
hosts=()

match_host () { 
    eval "[[ $1 == $2 ]]" 2>/dev/null # ignore syntax error
}

next_host () {
    [[ -z "${hosts[host_index]}" ]] && return 1
    local IFS=' '; host=(${hosts[host_index]})
    ((host_index++))
    return 0
}

token () {
    local s=${1//'{name}'/${host[0]}}
    s=${s//'{i}'/${host_index}}
    echo "$s"
}

read_host_config() {
    [[ ! -d "$host_cache_path" ]] && mkdir "$host_cache_path"
    [[ -a "$HOME/.ssh/config" ]] && CONFIG_FILES+=("$HOME/.ssh/config")

    if need_flush "${CONFIG_FILES[@]}"; then
        content=$(read_host_config_from_ssh_config)
        echo "$content" > "$host_cache_file"
    else
        content=$(cat "$host_cache_file")
    fi 
}

select_hosts () {
    read_host_config

    local name="$1"
    [[ -z "$name" ]] && name='*' 
    set -f

    local name="${1:-*}"

    if [[ "$name" =~ $REGEXP_NUMBER ]]; then 
        hosts+=("$(sed -n "${name}p" <<< "$content")")
        return
    fi

    local IFS='
'
    for l in $content 
    do
        local IFS=' '; local host=($l)
        match_host "${host[0]}" "${name}" && hosts+=("$l")
    done
}

help () {
    case $1 in
        name)
echo 'usage: ser name [name] 

print config names

examples:
    ser name
    ser name "*"
    ser name "my*"
' ;;
        cp) 
echo 'usage: ser cp <from> <to> [pass to scp options] 

copy file to hosts 

examples:
    ser cp "file" "*:~/"
    ser cp "*:~/file" "save/to/path/file-{name}"
    ser cp "dir" "*:~/" -r
    ser cp "*:~/dir" "save/to/path/{name}" -r

tokens:
    (see "ser help o" tokes section)';;
        o) 
echo 'usage: ser o <host|index> [command] [redirect result to file] 

login or executed command on the remote host

examples:
    ser "host1"
    ser o "host1"
    ser "host1"
    ser "*" "ls"
    ser "*" "ls" "result-{name}"

tokens:
    {i} - config index
    {name} - config name';;
        session-add|add)
echo 'usage: ser session-add <session_name> <host> local [bind_address:]<bind_port> [read_address>:]<read_port>
       ser session-add <session_name> <host> local [read_address:]<read_port> [bind_address>:]<bind_port>';;
        session-remove|rm)
echo 'usage: ser session-remove <session_name> <forward index>' ;;
        *) 
echo 'usage: ser <command> 

Type "ser help <command>" for help on a specific command.

Available commands:
    o|<host|pattern|index>    : open ssh client
    name                      : list all config names  
    cp                        : copy file to hosts

    session-add|add           : add forward to session
    session-remove|rm         : remove forward from session 
    session-start|start       : start sessions
    session-stop|stop         : stop sessions
    session-list|sl           : list all sessions
    session-check-step|step   : reconnect sessions if enabled

    help                      : show this message
'
echo "ver:${version},github:https://github.com/frimin/ser" ;;

    esac
}

show_host_list () {
    local host=()
    local IFS='
'
    local i=0
    for l in $1 
    do
        local IFS=' '; read -r -a host <<< "$l"
        local host_port=""
        ! [[ "${host[3]}" == "#" ]] && host_port=":${host[3]}"
        ((i++)); echo -e "$i) ${COLOR_LIGHT_GRAY}${host[0]}${NC} - ${host[1]}@${host[2]}${host_port}"
    done
}

ssh_connect () {
    select_hosts "$1"

    while next_host; 
    do
        [[ -z "$2" ]] && echo "connecting \"${host[0]}\""

        if [[ -n "$3" ]]; then
            ssh "${host[0]}" $"$2" > "$(token "$3")" || exit
        else
            ssh "${host[0]}" $"$2" || exit
        fi
    done

    [[ $host_index -eq 0 ]] && error "no matching host(s): $1"

    exit 0
}

read_session_alived_status() {
    pgrep -U "$(id -u)" -fl ssh | grep -E '^[0-9]+ ssh .*'"$host_forward_sessions_dirname"
}

read_session_enabled_status() {
    cat "$host_forward_sessions/"*.enabled 2>/dev/null
}

select_session() {
    session_alive_status=$(read_session_alived_status)

    SESSION_INDEX=0
    SESSION=''
    SESSION_SETS=()

    for name in $host_forward_sessions/*.session
    do
        name=$(basename "$name")
        name="${name%.*}"
        #[[ ! "$name" =~ $REGEXP_SESSION_NAME ]] && error "illegal sesssion name: $name"
        SESSION_SETS+=("$name")
    done
}

select_session_by_name() {
    [[ ! "$1" =~ $REGEXP_SESSION_NAME ]] && error "illegal sesssion name: $1"

    session_alive_status=$(read_session_alived_status)

    SESSION_INDEX=0
    SESSION=''
    SESSION_SETS=()

    if [[ -a "$host_forward_sessions/$1.session" ]]; then
        SESSION_SETS+=("$1")
    fi
}

select_session_alived() {
    session_alive_status=$(read_session_alived_status)

    SESSION_INDEX=0
    SESSION=''
    SESSION_SETS=()

    while read -r LINE
    do
        if [[ -z "$LINE" ]]; then break; fi
        local IFS='/'; local arr=($LINE)
        local name="${arr[${#arr[@]}-1]}" # last one, it's socket filename 
        name="${name%.*}"
        SESSION_SETS+=("$name")
    done <<< "$(grep -E -o "ControlPath=.*\.sock" <<< "$session_alive_status")"
}

next_session () {
    [[ -z "${SESSION_SETS[SESSION_INDEX]}" ]] && return 1
    SESSION="${SESSION_SETS[SESSION_INDEX]}"
    ((SESSION_INDEX++))
    return 0
}

select_forward_from_session() {
    FORWARD_INDEX=0
    FORWARD=()
    FORWARD_SETS=()

    local IFS='
'
    FORWARD_SETS=($(cat "$host_forward_sessions/$SESSION.session"))
}

next_forward () {
    [[ -z "${FORWARD_SETS[FORWARD_INDEX]}" ]] && return 1
    local IFS=' '; FORWARD=(${FORWARD_SETS[FORWARD_INDEX]})
    [[ ${#FORWARD[@]} -ne 4 ]] && error "invalid forward line: ${FORWARD_SETS[FORWARD_INDEX]}"
    ((FORWARD_INDEX++))
    return 0
}

session_alived() {
    local count

    count="$(grep "ControlPath=$host_forward_sessions/$SESSION.sock" <<< "$session_alive_status" | wc -l | trim)"

    if [[ $count -eq 0 ]]; then
        return 1
    fi

    if [[ $count -eq 1 ]]; then
        return 0
    fi
    
    error "invalid session process alived count"
}

session_pid() {
    local IFS=' '
    local arr=($(grep "ControlPath=$host_forward_sessions/$SESSION.sock" <<< "$session_alive_status"))
    [[ "${arr[0]}" =~ $REGEXP_NUMBER ]] && echo "${arr[0]}"
}

session_enabled() {
    if [[ -a "$host_forward_sessions/$SESSION.enabled" ]]; then
        return 0
    else
        return 1
    fi
}

session_connect() {
    local ssh_options=(
        '-f'
        '-N'
        '-o' 'ControlMaster=auto'
        '-o' "ControlPath=$host_forward_sessions/${SESSION}.sock"
        '-o' 'ExitOnForwardFailure=yes'
        '-o' 'ConnectTimeout=30'
        '-o' 'ServerAliveInterval=30'
        '-o' 'ServerAliveCountMax=3'
        '-o' 'BatchMode=yes'
    )

    select_forward_from_session

    local target_host

    while next_forward
    do
        if [[ "$FORWARD_INDEX" -eq 1 ]]; then
            target_host="${FORWARD[0]}"
        fi

        case "${FORWARD[1]}" in 
            local) ssh_options+=('-L' "${FORWARD[2]}:${FORWARD[3]}") ;;
            remote) ssh_options+=('-R' "${FORWARD[2]}:${FORWARD[3]}") ;;
            *) error "invalid forward type: '${FORWARD[*]}'" ;;
        esac
    done

    touch "${host_forward_sessions}/${SESSION}.enabled" 

    ssh "$target_host" ${ssh_options[@]}
}

session_disconnect() {
    # disable session
    [[ -a "$host_forward_sessions/$SESSION.enabled" ]] && /bin/rm -f "$host_forward_sessions/$SESSION.enabled" 
    local pid; pid="$(session_pid)"
    [[ "$pid" =~ $REGEXP_NUMBER ]] && kill -s INT "$pid"
}

read_forward_address() {
    [[ "$1" =~ $REGEXP_SPACE ]] && error "illegal address, contains space: $1" 
    local IFS=':'
    local arr=($1)

    if [[ ${#arr[@]} -eq 1 ]]; then
        if [[ ! ${arr[0]} =~ $REGEXP_NUMBER ]]; then
            error "illegal address, invalid port: ${arr[0]}"
        fi
        echo "127.0.0.1:$1"
    elif [[ ${#arr[@]} -eq 2 ]]; then
        if [[ ! ${arr[1]} =~ $REGEXP_NUMBER ]]; then
            error "illegal address: $1"
        fi
        echo "$1"
    else
        error "illegal address: $1"
    fi
}

session_add() {
    [[ -z "$1" ]] && error "please enter a session name"
    [[ -z "$2" ]] && error "please enter a host"
    [[ -z "$3" ]] && error "please enter type name (local/remote)"
    [[ -z "$4" || -z "$5" ]] && error "please enter local and remote forward address" 

    if [[ ! "$1" =~ $REGEXP_SESSION_NAME ]]; then
        error "illegal sesssion name: $1"
    fi

    select_hosts "$2"

    local target_host

    while next_host; 
    do
        target_host="$host"
        break
    done

    if [[ -z "$target_host" ]]; then
        error "host not found: $2"
    fi

    case "$3" in 
        local) ;;
        remote)  ;;
        *) error "invalid type: $3" ;;
    esac

    local local_addr; local_addr="$(read_forward_address "$4")"
    local remote_addr; remote_addr="$(read_forward_address "$5")"

    select_session_by_name "$1"

    local forward_content="$target_host $3 $local_addr $remote_addr"

    [[ -d "$host_forward_sessions" ]] && mkdir -p "$host_forward_sessions"

    if next_session; then
        select_forward_from_session

        while next_forward; 
        do
             [[ "${FORWARD[0]}" != "$target_host" ]] && error "can't specify diffrent host in same session, exists host: ${FORWARD[0]}, try add: $target_host"
        done

        if echo "$forward_content" >> "$host_forward_sessions/$1.session"; then
            echo "add forward \"$forward_content\" to session \"$SESSION\" succeed"
        fi
    else
        if echo "$forward_content" > "$host_forward_sessions/$1.session"; then
            echo "add forward \"$forward_content\" to new session \"$1\" succeed"
        fi
    fi
}

session_remove() {
    [[ -z "$1" ]] && error "please enter a session name"

    select_session_by_name "$1"

    if ! next_session; then
        error "session \"$1\" not exists"
    fi

    if [[ -z "$2" || "$2" == "0" ]]; then
        session_alived && echo "stopping session"
        session_disconnect # will delete enable record file and try stop process
        echo "remove session \"$SESSION\""
        /bin/rm -f "$host_forward_sessions/$SESSION.session";
    else
        [[ ! "$2" =~ $REGEXP_NUMBER ]] && error "not a index: $2"
        local session_content; session_content=$(cat "$host_forward_sessions/$SESSION.session")
        if [[ "$(wc -l <<< "$session_content" | trim)" -ge "$2" ]]; then
            echo "rewrite session \"$SESSION\" to delete rule #$2"
            sed "$2d" <<< "$session_content" > "$host_forward_sessions/$SESSION.session";
        else
            error "session \"$SESSION\" not contain index $2"
        fi
    fi
}

if [[ -z "$1" ]]; then 
    read_host_config
    show_host_list "$content"; exit
fi

case $1 in
    help)
        help "$2" ;;
    name)
        select_hosts "$2"

        while next_host; 
        do
            echo "${host[0]}"
        done ;;
    cp)
        set -f; IFS=':'
        from=($2); to=($3)
        [[ ${#from[@]} -lt 2 && ${#to[@]} -lt 2 ]] && error "need to pass <host> or <index> for copy to or copy from" 

        if [[ ${#from[@]} -lt 2 ]]; then
            pattern="${to[0]}"
            from_path="$2"    
            from_head=""
            to_head="<host>:"
            to_path="${3#*:}"
        else
            pattern="${from[0]}"
            from_head="<host>:"
            from_path="${2#*:}"
            to_head=""
            to_path="$3"
        fi

        # echo "pattern \"$pattern\", ${from_head}${from_path} => ${to_head}${to_path}"

        select_hosts "$pattern"

        pass_options=(${@:4})

        while next_host; 
        do
            [[ -n "$from_head" ]] && from_head="${host[0]}:"
            [[ -n "$to_head" ]] && to_head="${host[0]}:"

            arg0="${from_head}$(token "${from_path}")"
            arg1="${to_head}$(token "${to_path}")"

            echo "copy \"${arg0}\" to \"${arg1}\""

            if ! [[ "${host[3]}" == "#" ]]; then
                scp -P "${host[3]}" ${pass_options[@]} "${arg0}" "${arg1}" || exit
            else
                scp ${pass_options[@]} "${arg0}" "${arg1}" || exit
            fi
        done ;;
    o)
        set -f; ssh_connect "$2" "$3" "$4" ;;  
    session-add|add)
        session_add "$2" "$3" "$4" "$5" "$6";;
    session-remove|rm)
        session_remove "$2" "$3";;
    session-list|sl)
        select_session

        while next_session
        do
            select_forward_from_session

            if session_enabled; then
                state="[${COLOR_GREEN}enabled${NC}]"
            else
                state="[${COLOR_RED}disabled${NC}]"
            fi

            if session_alived; then
                state="$state [${COLOR_GREEN}connected${NC}]"
            else
                state="$state [${COLOR_RED}disconnected${NC}]"
            fi

            while next_forward
            do
                if [[ "$FORWARD_INDEX" -eq 1 ]]; then
                    echo -e "$SESSION_INDEX) ${COLOR_LIGHT_GRAY}${SESSION}${NC} - [${FORWARD[0]}] ${state}"
                fi

                case "${FORWARD[1]}" in 
                    local) echo " - #$FORWARD_INDEX LocalForward ${FORWARD[2]} <= ${FORWARD[3]}" ;;
                    remote) echo " - #$FORWARD_INDEX RemoteForward ${FORWARD[2]} => ${FORWARD[3]}" ;;
                    *) error "invalid line: '$LINE'" ;;
                esac
            done
        done
        ;;
    session-start|start)
        [[ -z "$2" ]] && session_name='*' || session_name="$2"

        select_session

        set -f;

        while next_session
        do
            if [[ "${SESSION}" == ''$session_name ]]; then
                if session_enabled && session_alived; then
                    echo -e "[${COLOR_GREEN}START SESSION${NC}] - $SESSION (has been started, ignore it)"
                    continue
                fi

                echo -e "[${COLOR_GREEN}START SESSION${NC}] - $SESSION: \c"

                if session_connect; then
                    echo 'OK'
                else
                    echo "FAILED, EXIT CODE: $?"
                fi
            fi
        done
        ;;
    session-stop|stop)
        [[ -z "$2" ]] && session_name='*' || session_name="$2"

        select_session

        set -f;

        while next_session
        do
            if session_enabled || session_alived; then
                echo -e "[${COLOR_RED}STOP SESSION${NC}] - $SESSION"
                session_disconnect
            fi
        done

        select_session_alived 

        while next_session
        do
            if [[ "$SESSION" == ''$session_name ]]; then
                echo -e "[${COLOR_RED}STOP UNMANAGED SESSION${NC}] - $SESSION "
                session_disconnect
            fi
        done ;;
    session-check-step|check)
        select_session

        while next_session
        do
            select_forward_from_session

            if ! session_enabled; then
                continue
            fi

            if session_alived; then
                continue
            fi
           
            echo -e "[${COLOR_GREEN}START SESSION${NC}] - $SESSION: \c"

            if session_connect; then
                echo 'OK'
            else
                echo "FAILED, EXIT CODE: $?"
            fi

        done ;;
    *)
        set -f; IFS=''; ssh_connect "$1" "$2" "$3" ;; 
esac

