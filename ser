#!/usr/bin/env bash

SER_SSH_CONFIG="${SER_SSH_CONFIG:-/etc/ssh/ssh_config:$HOME/.ssh/config}"
SER_OPTIONS_PATH="${SER_OPTIONS_PATH:-$HOME/.ser}"

SER_LAST_VERSION_URL="${SER_LAST_VERSION_URL:-https://frimin.com/update/ser/last/version}"
SER_LAST_SCRIPT_URL="${SER_LAST_SCRIPT_URL:-https://frimin.com/update/ser/last/ser}"

## General options ## 

SER_BASENAME="$(basename "$0")"
SER_PATH="$(cd "$(dirname "$0")" && pwd)/$SER_BASENAME"

host_cache_file="$SER_OPTIONS_PATH/cache"
host_cache_date="$SER_OPTIONS_PATH/cache_date"
host_forward_tunnels_dirname='forward_tunnels'
host_forward_tunnels="$SER_OPTIONS_PATH/$host_forward_tunnels_dirname"

VERSION='0.0.3a2#1'

COLOR_LIGHT_GRAY='\033[0;37m'
COLOR_GREEN='\033[0;32m'
COLOR_RED='\033[0;31m'
NC='\033[0m'

REGEXP_NUMBER='^[0-9]+$'
REGEXP_TUNNEL_NAME='^[A-Za-z0-9_\-]+$'
REGEXP_SPACE='[ \n\t\r\f\v]+'

error () { echo "$1" >&2; exit 2; }
trim () { while read -r line; do echo "$line"; done; }

need_check_update() {
    if [[ -a "$SER_OPTIONS_PATH/last_check_update" ]]; then
        # check update per week
        if [[ $(( $(date +%s) - $(cat "$SER_OPTIONS_PATH/last_check_update") )) -lt 604800 ]]; then
            return 1
        fi
    fi

    return 0
}

check_update() {
    date +%s > "$SER_OPTIONS_PATH/last_check_update"

    local IFS='#'
    local last_ver 

    if ! last_ver=($(curl -s -f "$SER_LAST_VERSION_URL")); then
        local msg="failed to check update: $SER_LAST_VERSION_URL"
        if [[ -n "$1" ]]; then
            echo "$msg" >&2
            return 1
        else
            error "$msg" 
        fi
    fi

    local this_ver=($VERSION)

    if [[ ${last_ver[1]} -gt ${this_ver[1]} ]]; then
        echo "new version available, lastest: ${last_ver[*]}, current: $VERSION"
        [[ -n "$1" ]] && echo "$1"
        return 0
    fi

    return 1
}

init_ssh_config_file() {
    SSH_CONFIG_FILES=()
    local IFS=':'

    for FILE in $SER_SSH_CONFIG
    do
        [[ -a $FILE ]] && SSH_CONFIG_FILES+=("$FILE")
    done

    [[ ${#SSH_CONFIG_FILES[@]} -eq 0 ]] && error "no available ssh config file: $SER_SSH_CONFIG"
}

## Config reader ## 

read_host_config_from_ssh_config() {
    check_host_name() {
        if [[ "$1" == "*" ]]; then return 0; fi
        if [[ "$1" == *"*"* || "$1" == *"?"* || "$1" == *"!"* || "$1" == *","* ]]; then return 1; fi
        return 0
    }

    [[ -z "${SSH_CONFIG_FILES[*]}" ]] && init_ssh_config_file

    local IFS='
'
    set -f

    local host; local content

    for l in $(cat "${SSH_CONFIG_FILES[@]}" | trim) 
    do
        local IFS='#'; read -r -a l <<< "$l"; local IFS=" "; local options=()

        for p in ${l[0]}; do options+=($p); done

        case ${options[0]} in
            Host)
                if [[ -n "${host[*]}" ]]; then
                    [[ -n ${host[3]} ]] && host_port="${host[3]}" || host_port="#"
                    content+="${host[0]} ${host[1]} ${host[2]} ${host_port}\n"    
                fi

                check_host_name "${options[1]}" || error "sorry, patterns not support: ${options[1]}"

                if [[ ${options[1]} == "*" ]]; then
                    host=(); continue
                fi

                host=(${options[1]} $USER "" "") ;;
            User) 
                [[ -n "${host[*]}" ]] && host[1]=${options[1]} ;;
            HostName) 
                [[ -n "${host[*]}" ]] && host[2]=${options[1]} ;;
            Port) 
                [[ -n "${host[*]}" ]] && host[3]=${options[1]} ;;
            Match)
                error "sorry, 'Match' option not support" ;;
            *) ;;
        esac
    done
 
    # handle last one
    if [[ -n "${host[*]}" ]]; then
        [[ -n ${host[3]} ]] && host_port="${host[3]}" || host_port="#"
        content+="${host[0]} ${host[1]} ${host[2]} ${host_port}\n"    
    fi

    echo -e "$content"
}

need_flush() {
    [[ -z "${SSH_CONFIG_FILES[*]}" ]] && init_ssh_config_file

    local last; local cur

    [[ -a "$host_cache_date" ]] && last=$(cat "$host_cache_date") 

    case $(uname) in
        Linux) 
            cur=$(sha1sum <<< "$VERSION $(stat --printf="%Y" ${SSH_CONFIG_FILES[@]})") ;;
        Darwin) 
            cur=$(shasum <<< "$VERSION $(stat -f "%m" ${SSH_CONFIG_FILES[@]})") ;;
        *) 
            error "failed to read file modify time on $(uname)" ;;
    esac

    if [[ "$last" == "$cur" ]]; then
        return 1
    else
        echo "$cur" > "$host_cache_date"
        return 0
    fi
}

host_index=0
host=()
hosts=()

match_host () { 
    eval "[[ $1 == $2 ]]" 2>/dev/null # ignore syntax error
}

next_host () {
    [[ -z "${hosts[host_index]}" ]] && return 1
    local IFS=' '; host=(${hosts[host_index]})
    ((host_index++))
    return 0
}

token () {
    local s=${1//'{name}'/${host[0]}}
    s=${s//'{i}'/${host_index}}
    echo "$s"
}

read_host_config() {
    [[ -a "$HOME/.ssh/config" ]] && CONFIG_FILES+=("$HOME/.ssh/config")

    if need_flush "${CONFIG_FILES[@]}"; then
        content=$(read_host_config_from_ssh_config)
        echo "$content" > "$host_cache_file"
    else
        content=$(cat "$host_cache_file")
    fi 
}

select_hosts () {
    read_host_config

    local name="$1"
    [[ -z "$name" ]] && name='*' 
    set -f

    local name="${1:-*}"

    if [[ "$name" =~ $REGEXP_NUMBER ]]; then 
        hosts+=("$(sed -n "${name}p" <<< "$content")")
        return
    fi

    local IFS='
'
    for l in $content 
    do
        local IFS=' '; local host=($l)
        match_host "${host[0]}" "${name}" && hosts+=("$l")
    done
}

help () {
    case $1 in
        name)
echo "Usage: $SER_BASENAME name [name] 

print config names

examples:
    $SER_BASENAME name
    $SER_BASENAME name \"*\"
    $SER_BASENAME name \"my*\"
" ;;
        cp) 
echo "Usage: $SER_BASENAME cp <from> <to> [pass to scp options] 

copy file to hosts 

examples:
    $SER_BASENAME cp \"file\" \"*:~/\"
    $SER_BASENAME cp \"*:~/file\" \"save/to/path/file-{name}\"
    $SER_BASENAME cp \"dir\" \"*:~/\" -r
    $SER_BASENAME cp \"*:~/dir\" \"save/to/path/{name}\" -r

tokens:
    (see \"$SER_BASENAME help o\" tokes section)";;
        o) 
echo "Usage: $SER_BASENAME o <host|index> [command] [redirect result to file] 

login or executed command on the remote host

examples:
    $SER_BASENAME \"host1\"
    $SER_BASENAME o \"host1\"
    $SER_BASENAME \"host1\"
    $SER_BASENAME \"*\" \"ls\"
    $SER_BASENAME \"*\" \"ls\" \"result-{name}\"

tokens:
    {i} - config index
    {name} - config name";;
        tunnel-add|add)
echo "Usage: $SER_BASENAME tunnel-add <tunnel_name> <host> local [bind_address:]<bind_port> [host:]<host_port>
       $SER_BASENAME tunnel-add <tunnel_name> <host> remote [bind_address:]<bind_port> [host>:]<host_port>";;
        tunnel-remove|rm)
echo "Usage: $SER_BASENAME tunnel-remove <tunnel_name> <forward_index>" ;;
        tunnel-start|start)
echo "Usage: $SER_BASENAME tunnel-start [tunnel_name|pattern]" ;;
        tunnel-restart|restart)
echo "Usage: $SER_BASENAME tunnel-restart [tunnel_name|pattern]" ;;
        tunnel-stop|stop)
echo "Usage: $SER_BASENAME tunnel-stop [tunnel_name|pattern]" ;;
        tunnel-list|tl)
echo "Usage: $SER_BASENAME tunnel-list" ;;
        tunnel-check-step|check)
echo "Usage: $SER_BASENAME tunnel-check-step

Remember add task to crontab:

\"crontab <<< '0-59 * * * * bash '$SER_PATH' tunnel-check-step\" " ;;
        *) 
echo "Usage: $SER_BASENAME <command> 

Type \"$SER_BASENAME help <command>\" for help on a specific command.

Available commands:
    o|<host|pattern|index>    : Login to host
    name                      : List all config names  
    cp                        : Copy file to hosts

    tunnel-add|add            : Add forward to tunnel
    tunnel-remove|rm          : Remove forward from tunnel 
    tunnel-start|start        : Start and enable tunnels
    tunnel-restart|restart    : Restart tunnels if enabled
    tunnel-stop|stop          : Stop and disable tunnels
    tunnel-list|tl            : List all tunnels
    tunnel-check-step|check   : Reconnect tunnels if enabled

    update                    : Update this program to latest version, Make sure that you have sufficient permissions
    help                      : Show this message
"
echo "ver:${VERSION},github:https://github.com/frimin/ser" ;;

    esac
}

show_host_list () {
    local host=()
    local IFS='
'
    local i=0
    for l in $1 
    do
        local IFS=' '; read -r -a host <<< "$l"
        local host_port=""
        ! [[ "${host[3]}" == "#" ]] && host_port=":${host[3]}"
        ((i++)); echo -e "$i) ${COLOR_LIGHT_GRAY}${host[0]}${NC} - ${host[1]}@${host[2]}${host_port}"
    done
}

ssh_connect () {
    select_hosts "$1"

    while next_host; 
    do
        [[ -z "$2" ]] && echo "connecting \"${host[0]}\""

        if [[ -n "$3" ]]; then
            ssh "${host[0]}" $"$2" > "$(token "$3")" || exit
        else
            ssh "${host[0]}" $"$2" || exit
        fi
    done

    [[ $host_index -eq 0 ]] && error "no matching host(s): $1"

    exit 0
}

read_tunnel_alived_status() {
    pgrep -U "$(id -u)" -fl ssh | grep -E '^[0-9]+ ssh .*'"$host_forward_tunnels_dirname"
}

read_tunnel_enabled_status() {
    cat "$host_forward_tunnels/"*.enabled 2>/dev/null
}

select_tunnel() {
    tunnel_alive_status=$(read_tunnel_alived_status)

    TUNNEL_INDEX=0
    TUNNEL=''
    TUNNEL_SETS=()

    for name in $host_forward_tunnels/*.tunnel
    do
        name=$(basename "$name")
        name="${name%.*}"
        #[[ ! "$name" =~ $REGEXP_TUNNEL_NAME ]] && error "illegal sesssion name: $name"
        TUNNEL_SETS+=("$name")
    done
}

select_tunnel_by_name() {
    [[ ! "$1" =~ $REGEXP_TUNNEL_NAME ]] && error "illegal sesssion name: $1"

    tunnel_alive_status=$(read_tunnel_alived_status)

    TUNNEL_INDEX=0
    TUNNEL=''
    TUNNEL_SETS=()

    if [[ -a "$host_forward_tunnels/$1.tunnel" ]]; then
        TUNNEL_SETS+=("$1")
    fi
}

select_tunnel_alived() {
    tunnel_alive_status=$(read_tunnel_alived_status)

    TUNNEL_INDEX=0
    TUNNEL=''
    TUNNEL_SETS=()

    while read -r LINE
    do
        if [[ -z "$LINE" ]]; then break; fi
        local IFS='/'; local arr=($LINE)
        local name="${arr[${#arr[@]}-1]}" # last one, it's socket filename 
        name="${name%.*}"
        TUNNEL_SETS+=("$name")
    done <<< "$(grep -E -o "ControlPath=.*\.sock" <<< "$tunnel_alive_status")"
}

next_tunnel () {
    [[ -z "${TUNNEL_SETS[TUNNEL_INDEX]}" ]] && return 1
    TUNNEL="${TUNNEL_SETS[TUNNEL_INDEX]}"
    ((TUNNEL_INDEX++))
    return 0
}

select_forward_from_tunnel() {
    FORWARD_INDEX=0
    FORWARD=()
    FORWARD_SETS=()

    local IFS='
'
    FORWARD_SETS=($(cat "$host_forward_tunnels/$TUNNEL.tunnel"))
}

next_forward () {
    [[ -z "${FORWARD_SETS[FORWARD_INDEX]}" ]] && return 1
    local IFS=' '; FORWARD=(${FORWARD_SETS[FORWARD_INDEX]})
    [[ ${#FORWARD[@]} -ne 4 ]] && error "invalid forward line: ${FORWARD_SETS[FORWARD_INDEX]}"
    ((FORWARD_INDEX++))
    return 0
}

tunnel_alived() {
    local count

    count="$(grep -c "ControlPath=$host_forward_tunnels/$TUNNEL.sock" <<< "$tunnel_alive_status")"

    if [[ $count -eq 0 ]]; then
        return 1
    fi

    if [[ $count -eq 1 ]]; then
        return 0
    fi
    
    error "invalid tunnel process alived count"
}

tunnel_pid() {
    local IFS=' '
    local arr=($(grep "ControlPath=$host_forward_tunnels/$TUNNEL.sock" <<< "$tunnel_alive_status"))
    [[ "${arr[0]}" =~ $REGEXP_NUMBER ]] && echo "${arr[0]}"
}

tunnel_enabled() {
    if [[ -a "$host_forward_tunnels/$TUNNEL.enabled" ]]; then
        return 0
    else
        return 1
    fi
}

tunnel_connect() {
    local ssh_options=(
        '-f'
        '-N'
        '-o' 'ControlMaster=auto'
        '-o' "ControlPath=$host_forward_tunnels/${TUNNEL}.sock"
        '-o' 'ExitOnForwardFailure=yes'
        '-o' 'ConnectTimeout=30'
        '-o' 'ServerAliveInterval=30'
        '-o' 'ServerAliveCountMax=3'
        '-o' 'BatchMode=yes'
    )

    select_forward_from_tunnel

    local target_host

    while next_forward
    do
        if [[ "$FORWARD_INDEX" -eq 1 ]]; then
            target_host="${FORWARD[0]}"
        fi

        case "${FORWARD[1]}" in 
            local) ssh_options+=('-L' "${FORWARD[2]}:${FORWARD[3]}") ;;
            remote) ssh_options+=('-R' "${FORWARD[2]}:${FORWARD[3]}") ;;
            *) error "invalid forward type: '${FORWARD[*]}'" ;;
        esac
    done

    touch "${host_forward_tunnels}/${TUNNEL}.enabled" 

    ssh "$target_host" ${ssh_options[@]}
}

tunnel_disconnect() {
    # disable tunnel
    [[ -a "$host_forward_tunnels/$TUNNEL.enabled" ]] && /bin/rm -f "$host_forward_tunnels/$TUNNEL.enabled" 
    local pid; pid="$(tunnel_pid)"
    [[ "$pid" =~ $REGEXP_NUMBER ]] && kill -s INT "$pid"
}

read_forward_address() {
    [[ "$1" =~ $REGEXP_SPACE ]] && error "illegal address, contains space: $1" 
    local IFS=':'
    local arr=($1)

    if [[ ${#arr[@]} -eq 1 ]]; then
        if [[ ! ${arr[0]} =~ $REGEXP_NUMBER ]]; then
            error "illegal address, invalid port: ${arr[0]}"
        fi
        echo "127.0.0.1:$1"
    elif [[ ${#arr[@]} -eq 2 ]]; then
        if [[ ! ${arr[1]} =~ $REGEXP_NUMBER ]]; then
            error "illegal address: $1"
        fi
        echo "$1"
    else
        error "illegal address: $1"
    fi
}

tunnel_add() {
    [[ -z "$1" ]] && error "please enter a tunnel name"
    [[ -z "$2" ]] && error "please enter a host"
    [[ -z "$3" ]] && error "please enter type name (local/remote)"
    [[ -z "$4" || -z "$5" ]] && error "please enter local and remote forward address" 

    if [[ ! "$1" =~ $REGEXP_TUNNEL_NAME ]]; then
        error "illegal sesssion name: $1"
    fi

    select_hosts "$2"

    local target_host

    while next_host; 
    do
        target_host="$host"
        break
    done

    if [[ -z "$target_host" ]]; then
        error "host not found: $2"
    fi

    case "$3" in 
        local|remote) ;;
        *) error "invalid type: $3" ;;
    esac

    local bind_addr; bind_addr="$(read_forward_address "$4")"
    local read_addr; read_addr="$(read_forward_address "$5")"

    select_tunnel_by_name "$1"

    local forward_content="$target_host $3 $bind_addr $read_addr"

    [[ ! -d "$host_forward_tunnels" ]] && mkdir -p "$host_forward_tunnels"

    if next_tunnel; then
        select_forward_from_tunnel

        while next_forward; 
        do
             [[ "${FORWARD[0]}" != "$target_host" ]] && error "can't specify diffrent host in same tunnel, exists host: ${FORWARD[0]}, try add: $target_host"
        done

        if echo "$forward_content" >> "$host_forward_tunnels/$1.tunnel"; then
            echo "add forward \"$forward_content\" to tunnel \"$TUNNEL\" succeed"
        fi
    else
        if echo "$forward_content" > "$host_forward_tunnels/$1.tunnel"; then
            echo "add forward \"$forward_content\" to new tunnel \"$1\" succeed"
        fi
    fi
}

tunnel_remove() {
    [[ -z "$1" ]] && error "please enter a tunnel name"

    select_tunnel_by_name "$1"

    if ! next_tunnel; then
        error "tunnel \"$1\" not exists"
    fi

    if [[ -z "$2" || "$2" == "0" ]]; then
        tunnel_alived && echo "stopping tunnel"
        tunnel_disconnect # will delete enable record file and try stop process
        echo "remove tunnel \"$TUNNEL\""
        /bin/rm -f "$host_forward_tunnels/$TUNNEL.tunnel";
    else
        [[ ! "$2" =~ $REGEXP_NUMBER ]] && error "not a index: $2"
        local tunnel_content; tunnel_content=$(cat "$host_forward_tunnels/$TUNNEL.tunnel")
        if [[ "$(wc -l <<< "$tunnel_content" | trim)" -ge "$2" ]]; then
            echo "rewrite tunnel \"$TUNNEL\" to delete rule #$2"
            sed "$2d" <<< "$tunnel_content" > "$host_forward_tunnels/$TUNNEL.tunnel";
        else
            error "tunnel \"$TUNNEL\" not contain index $2"
        fi
    fi
}

[[ ! -d "$SER_OPTIONS_PATH" ]] && mkdir "$SER_OPTIONS_PATH"

if [[ -z "$1" ]]; then 
    read_host_config
    show_host_list "$content"; 
    need_check_update && check_update "use: \"ser update\" update to lastest version"
    exit
fi

case $1 in
    help)
        help "$2" ;;
    name)
        select_hosts "$2"

        while next_host; 
        do
            echo "${host[0]}"
        done ;;
    cp)
        set -f; IFS=':'
        from=($2); to=($3)
        [[ ${#from[@]} -lt 2 && ${#to[@]} -lt 2 ]] && error "need to pass <host> or <index> for copy to or copy from" 

        if [[ ${#from[@]} -lt 2 ]]; then
            pattern="${to[0]}"
            from_path="$2"    
            from_head=""
            to_head="<host>:"
            to_path="${3#*:}"
        else
            pattern="${from[0]}"
            from_head="<host>:"
            from_path="${2#*:}"
            to_head=""
            to_path="$3"
        fi

        # echo "pattern \"$pattern\", ${from_head}${from_path} => ${to_head}${to_path}"

        select_hosts "$pattern"

        pass_options=(${@:4})

        while next_host; 
        do
            [[ -n "$from_head" ]] && from_head="${host[0]}:"
            [[ -n "$to_head" ]] && to_head="${host[0]}:"

            arg0="${from_head}$(token "${from_path}")"
            arg1="${to_head}$(token "${to_path}")"

            echo "copy \"${arg0}\" to \"${arg1}\""

            if ! [[ "${host[3]}" == "#" ]]; then
                scp -P "${host[3]}" ${pass_options[@]} "${arg0}" "${arg1}" || exit
            else
                scp ${pass_options[@]} "${arg0}" "${arg1}" || exit
            fi
        done ;;
    o)
        set -f; ssh_connect "$2" "$3" "$4" ;;  
    tunnel-add|add)
        tunnel_add "$2" "$3" "$4" "$5" "$6";;
    tunnel-remove|rm)
        tunnel_remove "$2" "$3";;
    tunnel-list|tl)
        select_tunnel

        while next_tunnel
        do
            select_forward_from_tunnel

            if tunnel_enabled; then
                state="[${COLOR_GREEN}enabled${NC}]"
            else
                state="[${COLOR_RED}disabled${NC}]"
            fi

            if tunnel_alived; then
                state="$state [${COLOR_GREEN}connected${NC}]"
            else
                state="$state [${COLOR_RED}disconnected${NC}]"
            fi

            while next_forward
            do
                if [[ "$FORWARD_INDEX" -eq 1 ]]; then
                    echo -e "$TUNNEL_INDEX) ${COLOR_LIGHT_GRAY}${TUNNEL}${NC} - [${FORWARD[0]}] ${state}"
                fi

                case "${FORWARD[1]}" in 
                    local) echo " - #$FORWARD_INDEX Forward (local) ${FORWARD[2]} <= (remote) ${FORWARD[3]}" ;;
                    remote) echo " - #$FORWARD_INDEX Forward (local) ${FORWARD[3]} => (remote) ${FORWARD[2]}" ;;
                    *) error "invalid line: '$LINE'" ;;
                esac
            done
        done
        ;;
    tunnel-start|start)
        [[ -z "$2" ]] && tunnel_name='*' || tunnel_name="$2"

        select_tunnel

        set -f;

        while next_tunnel
        do
            if [[ "${TUNNEL}" == ''$tunnel_name ]]; then
                if tunnel_enabled && tunnel_alived; then
                    echo -e "[${COLOR_GREEN}START TUNNEL${NC}] - $TUNNEL (has been started, ignore it)"
                    continue
                fi

                echo -e "[${COLOR_GREEN}START TUNNEL${NC}] - $TUNNEL: \c"

                if tunnel_connect; then
                    echo 'OK'
                else
                    echo "FAILED, EXIT CODE: $?"
                fi
            fi
        done
        ;;
    tunnel-stop|stop)
        [[ -z "$2" ]] && tunnel_name='*' || tunnel_name="$2"

        select_tunnel

        set -f;

        while next_tunnel
        do
            if [[ "${TUNNEL}" != ''$tunnel_name ]]; then
                continue
            fi

            if tunnel_enabled || tunnel_alived; then
                echo -e "[${COLOR_RED}STOP TUNNEL${NC}] - $TUNNEL"
                tunnel_disconnect
            fi
        done

        select_tunnel_alived 

        while next_tunnel
        do
            if [[ "${TUNNEL}" != ''$tunnel_name ]]; then
                continue
            fi

            if [[ "$TUNNEL" == ''$tunnel_name ]]; then
                echo -e "[${COLOR_RED}STOP UNMANAGED TUNNEL${NC}] - $TUNNEL "
                tunnel_disconnect
            fi
        done ;;
    tunnel-restart|restart)
        [[ -z "$2" ]] && tunnel_name='*' || tunnel_name="$2"

        select_tunnel

        set -f;

        while next_tunnel
        do
            if [[ "${TUNNEL}" != ''$tunnel_name ]]; then
                continue
            fi

            if tunnel_enabled; then
                echo -e "[${COLOR_GREEN}RESTART TUNNEL${NC}] - $TUNNEL\n"
                tunnel_disconnect

                if tunnel_connect; then
                    echo 'OK'
                else
                    echo "FAILED, EXIT CODE: $?"
                fi
            fi
        done ;;
    tunnel-check-step|check)
        select_tunnel

        while next_tunnel
        do
            select_forward_from_tunnel

            if ! tunnel_enabled; then
                continue
            fi

            if tunnel_alived; then
                continue
            fi
           
            echo -e "[${COLOR_GREEN}START TUNNEL${NC}] - $TUNNEL: \c"

            if tunnel_connect; then
                echo 'OK'
            else
                echo "FAILED, EXIT CODE: $?"
            fi

        done ;;
    update)
        echo "check update"
        if check_update ''; then
            echo "downloading"
            if new_content="$(curl -s -f "$SER_LAST_SCRIPT_URL")"; then
                echo "updating: $SER_PATH"
                echo "$new_content" > "$SER_PATH"
            else
                error "failed to download: $SER_LAST_SCRIPT_URL"
            fi
        else
            echo 'no update is available'
        fi ;;
    *)
        set -f; IFS=''; ssh_connect "$1" "$2" "$3" ;; 
esac

